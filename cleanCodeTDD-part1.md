 Laws:
  - The first law says that you're not allowed to write any production code until you've first written a failing unit test. 
  - The second law says that you can't write more of a unit test than is sufficient to fail, and not compiling is failing.
  - The third law says you aren't allowed to write more production code than is sufficient to pass the currently failing test.
  
  
 When you write your tests first, you have to design the production code to be accessible from the tests. Since you haven't written that production code yet, the tests have a tremendous influence on the design of the production code, and that influence is to make the production code testable. Writing tests first makes production code testable. And another word for testable is decoupled. The only way to test lines of code is to access them from the tests, but the only way to access them from the tests is to decouple the functions that contain them. So the act of writing your tests first causes you to have a system that is far less coupled than otherwise; in short, you get a better design simply by writing your tests first. 
 
 I'd like you to think about something. Why are design and architecture considered to be so important? Why are there so many books written on these topics? Why is so much effort applied to getting design and architecture right? It's because we want the structure of the system to be flexible, maintainable and scalable. When we add a new feature, we want to make sure that the structure of the system is flexible enough to allow those changes without breaking everything. And good designs do make systems more flexible and maintainable. But nothing makes a system more flexible than a suite of tests, by a huge order of magnitude. Because that suite of tests eliminates fear. If I give you a perfectly designed system, but no tests, you'll be afraid to clean it. You'll be afraid to improve it. And so, over time it will gradually degrade and rot. On the other hand, if I give you a terribly designed system but a comprehensive suite of tests, you will not be afraid to improve it, and so over time, it will gradually get better and better. The bottom line: if you want a flexible system, get a suite of tests that you trust. 
 
 How much trust do you have to have in those tests? I want you to think about those tests as though they were a parachute that you're gonna jump out of an airplane with. That's how much you have to trust them. After all, changing a working system is very risky. It's a lot like jumping out of an airplane, and you'd better have a good parachute. So how do you get a suite of tests that you trust with your life? Follow the three laws, follow them implicitly, follow them always. If every line of production code was written to make a failing unit test pass, then you will trust your test suite. If, on the other hand, you write your tests after the fact, then you'll never trust that test suite. You'll always worry that it's got holes in it. This is because testing after the fact is boring. You already know the code works because you've tested it manually. Writing tests after the fact is some kind of procedural milestone; it's not a necessary part of getting your code to work. You already know it works, you tested it manually. So it feels like make work, it feels like a waste. And that means you're gonna take shortcuts with it. You're going to take shortcuts with your parachute. There are some portions of the code that are just difficult to write tests for. You've tested them manually so you know they work, and therefore, you don't feel it's worth it to write a unit test. And so your test suite has holes, and you aren't going to jump out of an airplane when your parachute has holes.